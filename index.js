// Generated by CoffeeScript 1.10.0
(function() {
  var Asset, AssetGraph, UglifyJS, crypto, css, fs, htmlparser, join, os, path, requireJS, shell;

  htmlparser = require('htmlparser2');

  css = require('css');

  UglifyJS = require('uglify-js');

  path = require('path');

  join = path.join;

  fs = require('fs');

  os = require('os');

  crypto = require('crypto');

  shell = require('shelljs');

  requireJS = null;

  Asset = (function() {
    function Asset(root, filepath1, ag) {
      var absPath;
      this.root = root;
      this.filepath = filepath1;
      this.ag = ag != null ? ag : null;
      absPath = join(this.root, this.filepath);
      this.type = this._determineType(absPath);
      this.to = [];
      this.from = [];
      this.minify = false;
      this.pending = [];
      this.obj = this._buildObject(this.filepath, this.type);
    }

    Asset.prototype.move = function(destination) {
      var d, ext, f, i, len, oldpath, ref;
      oldpath = JSON.parse(JSON.stringify(this.filepath));
      ext = path.extname(destination);
      ref = this.from;
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        if (f.asset.type === 'style') {
          f.node.value = Asset.replaceStyleSheetUrl(f.node.value, destination);
        } else if (f.asset.type === 'javascript') {
          if (f.inRequireJS) {
            if (f.node.value.indexOf('text!') >= 0) {
              f.node.value = "text!" + destination;
            } else {
              d = join(path.dirname(destination), path.basename(destination, ext));
              if (d.indexOf('/') === 0) {
                d = d.substring(1);
              }
              f.node.value = d;
            }
          }
        } else if (f.asset.type === 'html') {
          if ((this.type === 'javascript') && f.inRequireJS) {
            f.node.attribs['data-main'] = join(path.dirname(destination), path.basename(destination, '.js'));
          } else if (this.type === 'style') {
            f.node.attribs.href = destination;
          } else {
            f.node.attribs.src = destination;
          }
        } else if (f.asset.type === 'image') {
          if (this.type === 'style') {
            f.node.value = "url(" + destination + ")";
          }
        } else {
          console.log('TODO: support type', f.asset.type, f.node, 'host type', this.type);
        }
      }
      this.filepath = destination;
      if (this.ag) {
        this.ag.addAsset(this);
        return delete this.ag.nodes[oldpath];
      }
    };

    Asset.prototype.resolveDependencies = function() {
      var added, asset, i, len, p, ref;
      ref = this.pending;
      for (i = 0, len = ref.length; i < len; i++) {
        p = ref[i];
        if (!this.ag.nodes[p.filepath]) {
          asset = new Asset(this.root, p.filepath, this.ag);
        } else {
          asset = this.ag.nodes[p.filepath];
        }
        if (asset.obj) {
          asset.from.push({
            asset: this,
            node: p.node,
            inRequireJS: p.inRequireJS
          });
          this.to.push({
            asset: asset,
            node: p.node,
            inRequireJS: p.inRequireJS
          });
          added = this.ag.addAsset(asset);
          if (added) {
            asset.resolveDependencies();
          }
        }
      }
      return this.pending = [];
    };

    Asset.prototype.writeToDisc = function(destination, useHashName) {
      var i, len, newPath, out, ref, t;
      this.written = true;
      if (useHashName || this.prefix) {
        ref = this.to;
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          if (!t.asset.written) {
            t.asset.writeToDisc(destination, useHashName);
          }
        }
      }
      if (useHashName && this.filepath !== 'index.html') {
        newPath = path.dirname(this.filepath) + '/' + this._hash() + path.extname(this.filepath);
      } else {
        newPath = destination + this.filepath;
      }
      if (useHashName || this.prefix) {
        if (this.filepath !== 'index.html') {
          if (this.prefix) {
            this.move('//' + this.prefix + newPath);
          } else {
            this.move(newPath);
          }
        }
      }
      out = this._toString();
      if (out) {
        if (this.filepath === 'index.html') {
          return fs.writeFileSync(join(destination, this.filepath), out);
        } else {
          return fs.writeFileSync(join(destination, newPath), out);
        }
      }
    };

    Asset.prototype._buildObject = function() {
      var absPath, d, file, filepath, handler, parser, result, type;
      result = null;
      filepath = this.filepath;
      type = this.type;
      absPath = join(this.root, filepath);
      if (!fs.existsSync(absPath)) {
        console.log("error:file " + absPath + " doesn't exist.");
      } else {
        file = fs.readFileSync(absPath, 'utf8');
        if (type === 'html') {
          if (file.indexOf('<%') >= 0) {
            console.log('warning: template directives found. Not parsing', filepath);
            return file;
          }
          d = null;
          handler = new htmlparser.DomHandler((function(_this) {
            return function(er, dom) {
              var i, len;
              if (er) {
                throw new Error(er);
              } else {
                for (i = 0, len = dom.length; i < len; i++) {
                  d = dom[i];
                  _this._parseDOMNode(d);
                }
              }
              return d = dom;
            };
          })(this));
          parser = new htmlparser.Parser(handler);
          parser.parseComplete(file);
          result = d;
        } else if (type === 'style') {
          result = this._parseStyleSheet(filepath, file);
        } else if (type === 'javascript') {
          result = this._parseJavascript(filepath, file);
        } else if (type === 'image') {
          result = fs.readFileSync(absPath);
        }
      }
      return result;
    };

    Asset.prototype._determineType = function(filepath) {
      var ext, type;
      ext = path.extname(filepath || '').split('.');
      ext = ext[ext.length - 1];
      if (ext === 'html' || ext === 'htm') {
        type = 'html';
      } else if (ext === 'js') {
        type = 'javascript';
      } else if (ext === 'css') {
        type = 'style';
      } else if (ext === 'png' || ext === 'gif' || ext === 'jpg' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {
        type = 'image';
      }
      return type;
    };

    Asset.prototype._foundAssetReference = function(filepath, node, inRequireJS) {
      if (inRequireJS == null) {
        inRequireJS = false;
      }
      if (!this.ag) {
        return;
      }
      if (!this.ag.nodes[filepath]) {
        console.log('loading ', filepath);
      }
      return this.pending.push({
        filepath: filepath,
        node: node,
        inRequireJS: inRequireJS
      });
    };

    Asset.prototype._hash = function() {
      var md5sum, out;
      out = this._toString();
      md5sum = crypto.createHash('md5');
      md5sum.update(out);
      return md5sum.digest('hex');
    };

    Asset.prototype._minify = function() {
      var compressor, d, ext, i, len, minified, outfile, ref, response, tmpfile;
      console.log('calling minify on', this.filepath, this.type);
      minified = '';
      if (this.type === 'javascript') {
        this.obj.figure_out_scope();
        compressor = UglifyJS.Compressor({
          unused: false
        });
        this.obj.transform(compressor);
        minified = this.obj.print_to_string({
          beautify: false
        });
      } else if (this.type === 'style') {
        minified = css.stringify(this.obj, {
          compress: true
        });
      } else if (this.type === 'html') {
        if (typeof this.obj === 'string') {
          minified = this.obj;
        } else {
          ref = this.obj;
          for (i = 0, len = ref.length; i < len; i++) {
            d = ref[i];
            minified += htmlparser.DomUtils.getOuterHTML(d);
          }
        }
      } else if (this.type === 'image') {
        minified = this.obj;
        ext = path.extname(this.filepath);
        if (ext === '.jpg' || ext === '.jpeg') {
          if (shell.which('jpegtran')) {
            console.log('optimizing', this.filepath, 'via jpegtran');
            tmpfile = join(os.tmpdir(), 'wag12345');
            outfile = join(os.tmpdir(), 'wag12345.out');
            fs.writeFileSync(tmpfile, this.obj);
            response = shell.exec("jpegtran -copy none -optimize -perfect -progressive -outfile " + outfile + " " + tmpfile, {
              silent: true
            });
            if (response.code !== 0) {
              console.log('something went wrong; failed to optimize', this.filepath, response.output);
            } else {
              minified = fs.readFileSync(outfile);
            }
            shell.rm(tmpfile);
            shell.rm(outfile);
          } else {
            console.log('WARN jpegtran is not installed, skipping optimizing ', this.filepath);
          }
        } else if (ext === '.png') {
          tmpfile = join(os.tmpdir(), 'wag12345');
          fs.writeFileSync(tmpfile, this.obj);
          if (shell.which('pngcrush')) {
            console.log('optimizing', this.filepath, 'via pngcrush');
            response = shell.exec("pngcrush -reduce -brute -ow " + tmpfile, {
              silent: true
            });
            if (response.code !== 0) {
              console.log('something went wrong; failed to optimize', this.filepath, response.output);
            }
          } else {
            console.log('WARN optipng is not installed, skipping optimizing ', this.filepath);
          }
          if (shell.which('optipng')) {
            console.log('optimizing', this.filepath, 'via optipng');
            response = shell.exec("optipng " + tmpfile, {
              silent: true
            });
            if (response.code !== 0) {
              console.log('something went wrong; failed to optimize', this.filepath, response.output);
            }
          } else {
            console.log('WARN optipng is not installed, skipping optimizing ', this.filepath);
          }
          if (shell.which('pngquant')) {
            console.log('optimizing', this.filepath, 'via pngquant');
            response = shell.exec("pngquant --force " + tmpfile, {
              silent: true
            });
            if (response.code !== 0) {
              console.log('something went wrong; failed to optimize', this.filepath, response.output);
            } else {
              shell.mv('-f', tmpfile + "-fs8.png", tmpfile);
            }
          } else {
            console.log('WARN pngquant is not installed, skipping optimizing ', this.filepath);
          }
          minified = fs.readFileSync(tmpfile);
          shell.rm(tmpfile);
        } else if (ext === '.svg') {
          if (shell.which('svgo')) {
            console.log('optimizing', this.filepath, 'via svgo');
            tmpfile = join(os.tmpdir(), 'wag12345');
            fs.writeFileSync(tmpfile, this.obj);
            response = shell.exec("svgo --input " + tmpfile + " --output -", {
              silent: true
            });
            if (response.code !== 0) {
              console.log('something went wrong; failed to optimize', this.filepath, response.output);
            } else {
              minified = response.output;
            }
          } else {
            console.log('WARN svgo is not installed, skipping optimizing ', this.filepath);
          }
        }
      }
      return minified;
    };

    Asset.prototype._parseDOMNode = function(node) {
      var i, inRequireJS, len, n, newAssetPath, ref, results;
      newAssetPath = null;
      inRequireJS = false;
      if (node.type === 'tag' && (node.name === 'style' || node.name === 'link')) {
        newAssetPath = node.attribs.href;
      } else if (node.type === 'script' && node.name === 'script') {
        if (!node.attribs || !node.attribs.src) {

        } else {
          if (node.attribs['data-main']) {
            console.log('found requirejs entry point', node.attribs.src, 'main', node.attribs['data-main']);
            newAssetPath = node.attribs['data-main'] + ".js";
            inRequireJS = true;
          } else {
            console.log('external script found', node.attribs.src);
            newAssetPath = node.attribs.src;
          }
        }
      } else if (node.type === 'tag' && node.name === 'img' && node.attribs.src && node.attribs.src !== 'src') {
        console.log("found image reference '" + node.attribs.src + "'");
        newAssetPath = node.attribs.src;
      }
      if (newAssetPath) {
        this._foundAssetReference(newAssetPath, node, inRequireJS);
      }
      if (node.children) {
        ref = node.children;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          n = ref[i];
          results.push(this._parseDOMNode(n));
        }
        return results;
      }
    };

    Asset.prototype._parseJavascript = function(filepath, file) {
      var opts, toplevel, walker;
      toplevel = null;
      opts = {};

      /*
      opts =
        filename : filepath
        toplevel : toplevel
       */
      toplevel = UglifyJS.parse(file, opts);
      walker = new UglifyJS.TreeWalker((function(_this) {
        return function(node) {
          if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'require') {
            if (node.expression.end.value === 'config') {
              requireJS = _this._parseRequireJSConfig(node);
            } else if (node.args.length === 2) {
              _this._parseRequireStatement(node);
            }
          }
          if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'define') {
            _this._parseRequireStatement(node);
          }
          return false;
        };
      })(this));
      toplevel.walk(walker);
      return toplevel;
    };

    Asset.prototype._parseRequireJSConfig = function(node) {
      var cfg, i, j, k, l, len, len1, ref, ref1;
      cfg = {};
      ref = node.args[0].properties;
      for (i = 0, len = ref.length; i < len; i++) {
        k = ref[i];
        if (k.key === 'baseUrl') {
          cfg.baseUrl = k.value.value;
        }
        if (k.key === 'paths') {
          cfg.paths = {};
          ref1 = k.value.properties;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            j = ref1[l];
            cfg.paths[j.key] = j.value.value;
          }
        }
      }
      return cfg;
    };

    Asset.prototype._parseRequireStatement = function(node) {
      var alias, found, i, inRequireJS, len, newAssetPath, p, pa, ref, ref1, results, scriptpath;
      if (!node.args[0].elements) {
        return;
      }
      p = requireJS ? requireJS.baseUrl : '';
      ref = node.args[0].elements;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        scriptpath = ref[i];
        newAssetPath = null;
        if (scriptpath.value) {
          if (scriptpath.value.indexOf('text!') === 0) {
            newAssetPath = join(p, scriptpath.value.substring(5));
          } else if (fs.existsSync(join(this.root, p, scriptpath.value + ".js"))) {
            newAssetPath = join(p, scriptpath.value + ".js");
          } else if (scriptpath.value === 'exports' || (requireJS && scriptpath.value === 'require')) {

          } else if (requireJS) {
            found = false;
            ref1 = requireJS.paths;
            for (alias in ref1) {
              pa = ref1[alias];
              if (alias === scriptpath.value) {
                found = true;
                newAssetPath = join(p, pa + ".js");
              }
            }
            if (!found) {
              console.log("error 1: could not find asset " + scriptpath.value);
            }
          } else {
            console.log("error: could not find asset " + scriptpath.value);
          }
        }
        inRequireJS = true;
        if (newAssetPath) {
          results.push(this._foundAssetReference(newAssetPath, scriptpath, inRequireJS));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Asset.prototype._parseStyleSheet = function(filepath, file) {
      var c, dec, fullpath, i, l, len, len1, ref, ref1, rule, url;
      c = css.parse(file);
      ref = c.stylesheet.rules;
      for (i = 0, len = ref.length; i < len; i++) {
        rule = ref[i];
        if (rule.type === 'rule') {
          ref1 = rule.declarations;
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            dec = ref1[l];
            if (dec.type === 'declaration' && (dec.property === 'background-image' || dec.property === 'background')) {
              url = Asset.parseStyleSheetUrl(dec.value);
              if (url) {
                if (url.indexOf('/') === 0) {
                  fullpath = url;
                } else {
                  fullpath = join(path.dirname(filepath), url);
                }
                this._foundAssetReference(fullpath, dec);
              }
            }
          }
        }
      }
      return c;
    };

    Asset.prototype._toString = function() {
      var d, i, len, ref, updated;
      if (this.minify) {
        return this._minify();
      }
      if (this.type === 'html') {
        if (typeof this.obj === 'string') {
          updated = this.obj;
        } else {
          updated = '';
          ref = this.obj;
          for (i = 0, len = ref.length; i < len; i++) {
            d = ref[i];
            updated += htmlparser.DomUtils.getOuterHTML(d);
          }
        }
      } else if (this.type === 'javascript') {
        updated = this.obj.print_to_string({
          beautify: false
        });
      } else if (this.type === 'style') {
        updated = css.stringify(this.obj, {
          compress: false
        });
      } else if (this.type === 'image') {
        updated = this.obj;
      } else {
        updated = '';
      }
      return updated;
    };

    Asset.parseStyleSheetUrl = function(declaration) {
      var b, pos, pos2, url;
      b = declaration.match(/url\((.+?)\)/gi);
      if (b) {
        pos = declaration.indexOf('url(');
        if (pos >= 0) {
          pos2 = declaration.indexOf(')', pos + 4);
          url = declaration.substring(pos + 4, pos2).trim();
          return url.replace(/"|'/g, '');
        }
      }
      return '';
    };

    Asset.replaceStyleSheetUrl = function(declaration, newUrl) {
      var currentUrl;
      currentUrl = Asset.parseStyleSheetUrl(declaration);
      return declaration.replace(currentUrl, newUrl);
    };

    return Asset;

  })();

  AssetGraph = (function() {
    function AssetGraph(root) {
      this.root = root;
      this.nodes = {};
      this.indexNode = null;
    }

    AssetGraph.prototype.addCacheManifest = function() {};

    AssetGraph.prototype.loadAssets = function(filepath) {
      var absPath, f, files, i, len, results;
      absPath = join(this.root, filepath);
      if (fs.statSync(absPath).isDirectory()) {
        files = fs.readdirSync(absPath);
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          f = files[i];
          results.push(this.loadAssets(join(filepath, f)));
        }
        return results;
      } else {
        return this._load(filepath);
      }
    };

    AssetGraph.prototype.minifyAssets = function() {
      var a, p, ref, results;
      ref = this.nodes;
      results = [];
      for (p in ref) {
        a = ref[p];
        results.push(a.minify = true);
      }
      return results;
    };

    AssetGraph.prototype.moveAssets = function(destination) {
      var a, newpath, p, ref, results;
      ref = this.nodes;
      results = [];
      for (p in ref) {
        a = ref[p];
        if (p !== 'index.html') {
          newpath = join('/', destination, '/', path.basename(p));
          results.push(a.move(newpath));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    AssetGraph.prototype.setUrlPrefix = function(prefix) {
      var a, p, ref, results;
      ref = this.nodes;
      results = [];
      for (p in ref) {
        a = ref[p];
        if (p !== 'index.html') {
          results.push(a.prefix = prefix);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    AssetGraph.prototype.writeAssetsToDisc = function(destination, useHashName) {
      var a, p, ref, ref1, results;
      if (useHashName == null) {
        useHashName = false;
      }
      ref = this.nodes;
      for (p in ref) {
        a = ref[p];
        a.written = false;
      }
      ref1 = this.nodes;
      results = [];
      for (p in ref1) {
        a = ref1[p];
        results.push(a.writeToDisc(destination, useHashName));
      }
      return results;
    };

    AssetGraph.prototype._load = function(filepath) {
      var a, absPath;
      absPath = join(this.root, filepath);
      if (!fs.existsSync(absPath)) {
        console.log("file " + absPath + " not found");
        return;
      }
      a = new Asset(this.root, filepath, this);
      this.indexNode || (this.indexNode = a);
      this.addAsset(a);
      return a.resolveDependencies();
    };

    AssetGraph.prototype.addAsset = function(asset) {
      if (!this.nodes[asset.filepath] && (asset.type != null)) {
        this.nodes[asset.filepath] = asset;
        return true;
      }
      return false;
    };

    return AssetGraph;

  })();

  module.exports.AssetGraph = AssetGraph;

  module.exports.Asset = Asset;

}).call(this);
