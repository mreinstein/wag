// Generated by CoffeeScript 1.6.3
(function() {
  var Asset, AssetGraph, UglifyJS, crypto, css, fs, htmlparser, join, path, requireJS, _;

  htmlparser = require('htmlparser2');

  css = require('css');

  UglifyJS = require('uglify-js');

  path = require('path');

  join = path.join;

  fs = require('fs');

  _ = require('underscore');

  crypto = require('crypto');

  /*
  # parse html string as an underscore.js template, returning the list of 
  # string locations for each dynamic section
  parseHtmlUnderscoreTemplate = (html) ->
  	idx = 0
  	open = false
  	dynamic = []
  	while idx < html.length and idx >= 0
  		if open
  			q = '%>'
  		else
  			q = '<%'
  		pos = html.indexOf q, idx
  		if pos > -1
  			if open
  				dynamic.push { start: idx-2, end: pos+2 }
  			open = !open
  			idx = pos + 2
  		else
  			idx = pos
  	# if any tags are left open, template has problemzz
  	if open and dynamic.length > 0
  		throw new Error('Invalid Template')
  	dynamic
  
  # given a DOM node, a set of changes, and a list of dynamic sections, product 
  # an Html string that applies all changes and inserts the dynamic parts in
  updateHtmlUnderscoreTemplate = (node, deltas, dynamic) ->
  	# TODO
  	# NOTE: templates/product.html is a great test example because it's large, 
  	#		and has all 3 underscore tag types used:  <%   <%=   <%-
  	''
  */


  requireJS = null;

  Asset = (function() {
    function Asset(root, filepath, ag) {
      var absPath;
      this.root = root;
      this.filepath = filepath;
      this.ag = ag != null ? ag : null;
      absPath = join(this.root, this.filepath);
      this.type = this._determineType(absPath);
      this.to = [];
      this.from = [];
      this.minify = false;
      this.pending = [];
      this.obj = this._buildObject(this.filepath, this.type);
    }

    Asset.prototype.move = function(destination) {
      var d, ext, f, oldpath, _i, _len, _ref;
      oldpath = JSON.parse(JSON.stringify(this.filepath));
      ext = path.extname(destination);
      _ref = this.from;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        if (f.asset.type === 'style') {
          f.node.value = "url(" + destination + ")";
        } else if (f.asset.type === 'javascript') {
          if (f.inRequireJS) {
            if (f.node.value.indexOf('text!') >= 0) {
              f.node.value = "text!" + destination;
            } else {
              d = join(path.dirname(destination), path.basename(destination, ext));
              if (d.indexOf('/') === 0) {
                d = d.substring(1);
              }
              f.node.value = d;
            }
          }
        } else if (f.asset.type === 'html') {
          if ((this.type === 'javascript') && f.inRequireJS) {
            f.node.attribs['data-main'] = join(path.dirname(destination), path.basename(destination, '.js'));
          } else if (this.type === 'style') {
            f.node.attribs.href = destination;
          } else {
            f.node.attribs.src = destination;
          }
        } else if (f.asset.type === 'image') {
          if (this.type === 'style') {
            f.node.value = "url(" + destination + ")";
          }
        } else {
          console.log('TODO: support type', f.asset.type, f.node, 'host type', this.type);
        }
      }
      this.filepath = destination;
      if (this.ag) {
        this.ag.addAsset(this);
        return delete this.ag.nodes[oldpath];
      }
    };

    Asset.prototype.resolveDependencies = function() {
      var added, asset, p, _i, _len, _ref;
      _ref = this.pending;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (!this.ag.nodes[p.filepath]) {
          asset = new Asset(this.root, p.filepath, this.ag);
        } else {
          asset = this.ag.nodes[p.filepath];
        }
        if (asset.obj) {
          asset.from.push({
            asset: this,
            node: p.node,
            inRequireJS: p.inRequireJS
          });
          this.to.push({
            asset: asset,
            node: p.node,
            inRequireJS: p.inRequireJS
          });
          added = this.ag.addAsset(asset);
          if (added) {
            asset.resolveDependencies();
          }
        }
      }
      return this.pending = [];
    };

    Asset.prototype.writeToDisc = function(destination, useHashName) {
      var newPath, out, t, _i, _len, _ref;
      this.written = true;
      if (useHashName || this.prefix) {
        _ref = this.to;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (!t.asset.written) {
            t.asset.writeToDisc(destination, useHashName);
          }
        }
      }
      if (useHashName && this.filepath !== 'index.html') {
        newPath = path.dirname(this.filepath) + '/' + this._hash() + path.extname(this.filepath);
      } else {
        newPath = destination + this.filepath;
      }
      if (useHashName || this.prefix) {
        if (this.filepath !== 'index.html') {
          if (this.prefix) {
            this.move('http://' + this.prefix + newPath);
          } else {
            this.move(newPath);
          }
        }
      }
      out = this._toString();
      if (out) {
        if (this.filepath === 'index.html') {
          return fs.writeFileSync(join(destination, this.filepath), out);
        } else {
          return fs.writeFileSync(join(destination, newPath), out);
        }
      }
    };

    Asset.prototype._buildObject = function() {
      var absPath, d, file, filepath, handler, parser, result, type,
        _this = this;
      result = null;
      filepath = this.filepath;
      type = this.type;
      absPath = join(this.root, filepath);
      if (!fs.existsSync(absPath)) {
        console.log("error:file " + absPath + " doesn't exist.");
      } else {
        file = fs.readFileSync(absPath, 'utf8');
        if (type === 'html') {
          if (file.indexOf('<%') >= 0) {
            console.log('warning: template directives found. Not parsing', filepath);
            return file;
          }
          d = null;
          handler = new htmlparser.DomHandler(function(er, dom) {
            var _i, _len;
            if (er) {
              throw new Error(er);
            } else {
              for (_i = 0, _len = dom.length; _i < _len; _i++) {
                d = dom[_i];
                _this._parseDOMNode(d);
              }
            }
            return d = dom;
          });
          parser = new htmlparser.Parser(handler);
          parser.parseComplete(file);
          result = d;
        } else if (type === 'style') {
          result = this._parseStyleSheet(filepath, file);
        } else if (type === 'javascript') {
          result = this._parseJavascript(filepath, file);
        } else if (type === 'image') {
          result = fs.readFileSync(absPath);
        }
      }
      return result;
    };

    Asset.prototype._determineType = function(filepath) {
      var ext, type;
      ext = path.extname(filepath || '').split('.');
      ext = ext[ext.length - 1];
      if (ext === 'html' || ext === 'htm') {
        type = 'html';
      } else if (ext === 'js') {
        type = 'javascript';
      } else if (ext === 'css') {
        type = 'style';
      } else if (ext === 'png' || ext === 'gif' || ext === 'jpg' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {
        type = 'image';
      }
      return type;
    };

    Asset.prototype._foundAssetReference = function(filepath, node, inRequireJS) {
      if (inRequireJS == null) {
        inRequireJS = false;
      }
      if (!this.ag) {
        return;
      }
      if (!this.ag.nodes[filepath]) {
        console.log('loading ', filepath);
      }
      return this.pending.push({
        filepath: filepath,
        node: node,
        inRequireJS: inRequireJS
      });
    };

    Asset.prototype._hash = function() {
      var md5sum, out;
      out = this._toString();
      md5sum = crypto.createHash('md5');
      md5sum.update(out);
      return md5sum.digest('hex');
    };

    Asset.prototype._minify = function() {
      var compressor, d, minified, _i, _len, _ref;
      minified = '';
      if (this.type === 'javascript') {
        this.obj.figure_out_scope();
        compressor = UglifyJS.Compressor({
          unused: false
        });
        this.obj.transform(compressor);
        minified = this.obj.print_to_string({
          beautify: false
        });
      } else if (this.type === 'style') {
        minified = css.stringify(this.obj, {
          compress: true
        });
      } else if (this.type === 'html') {
        if (typeof this.obj === 'string') {
          minified = this.obj;
        } else {
          _ref = this.obj;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            d = _ref[_i];
            minified += htmlparser.DomUtils.getOuterHTML(d);
          }
        }
      } else if (this.type === 'image') {
        minified = this.obj;
      }
      return minified;
    };

    Asset.prototype._parseDOMNode = function(node) {
      var inRequireJS, n, newAssetPath, _i, _len, _ref, _results;
      newAssetPath = null;
      inRequireJS = false;
      if (node.type === 'tag' && (node.name === 'style' || node.name === 'link')) {
        newAssetPath = node.attribs.href;
      } else if (node.type === 'script' && node.name === 'script') {
        if (!node.attribs || !node.attribs.src) {

        } else {
          if (node.attribs['data-main']) {
            console.log('found requirejs entry point', node.attribs.src, 'main', node.attribs['data-main']);
            newAssetPath = "" + node.attribs['data-main'] + ".js";
            inRequireJS = true;
          } else {
            console.log('external script found', node.attribs.src);
            newAssetPath = node.attribs.src;
          }
        }
      } else if (node.type === 'tag' && node.name === 'img' && node.attribs.src && node.attribs.src !== 'src') {
        console.log("found image reference '" + node.attribs.src + "'");
        newAssetPath = node.attribs.src;
      }
      if (newAssetPath) {
        this._foundAssetReference(newAssetPath, node, inRequireJS);
      }
      if (node.children) {
        _ref = node.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(this._parseDOMNode(n));
        }
        return _results;
      }
    };

    Asset.prototype._parseJavascript = function(filepath, file) {
      var opts, toplevel, walker,
        _this = this;
      toplevel = null;
      opts = {};
      /*
      		opts =
      			filename : filepath
      			toplevel : toplevel
      */

      toplevel = UglifyJS.parse(file, opts);
      walker = new UglifyJS.TreeWalker(function(node) {
        if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'require') {
          if (node.expression.end.value === 'config') {
            requireJS = _this._parseRequireJSConfig(node);
          } else if (node.args.length === 2) {
            _this._parseRequireStatement(node);
          }
        }
        if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'define') {
          _this._parseRequireStatement(node);
        }
        return false;
      });
      toplevel.walk(walker);
      return toplevel;
    };

    Asset.prototype._parseRequireJSConfig = function(node) {
      var cfg, j, k, _i, _j, _len, _len1, _ref, _ref1;
      cfg = {};
      _ref = node.args[0].properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        if (k.key === 'baseUrl') {
          cfg.baseUrl = k.value.value;
        }
        if (k.key === 'paths') {
          cfg.paths = {};
          _ref1 = k.value.properties;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            j = _ref1[_j];
            cfg.paths[j.key] = j.value.value;
          }
        }
      }
      return cfg;
    };

    Asset.prototype._parseRequireStatement = function(node) {
      var alias, found, inRequireJS, newAssetPath, p, pa, scriptpath, _i, _len, _ref, _ref1, _results;
      if (!node.args[0].elements) {
        return;
      }
      p = requireJS ? requireJS.baseUrl : '';
      _ref = node.args[0].elements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scriptpath = _ref[_i];
        newAssetPath = null;
        if (scriptpath.value) {
          if (scriptpath.value.indexOf('text!') === 0) {
            newAssetPath = join(p, scriptpath.value.substring(5));
          } else if (fs.existsSync(join(this.root, p, "" + scriptpath.value + ".js"))) {
            newAssetPath = join(p, "" + scriptpath.value + ".js");
          } else if (scriptpath.value === 'exports' || (requireJS && scriptpath.value === 'require')) {

          } else if (requireJS) {
            found = false;
            _ref1 = requireJS.paths;
            for (alias in _ref1) {
              pa = _ref1[alias];
              if (alias === scriptpath.value) {
                found = true;
                newAssetPath = join(p, "" + pa + ".js");
              }
            }
            if (!found) {
              console.log("error 1: could not find asset " + scriptpath.value);
            }
          } else {
            console.log("error: could not find asset " + scriptpath.value);
          }
        }
        inRequireJS = true;
        if (newAssetPath) {
          _results.push(this._foundAssetReference(newAssetPath, scriptpath, inRequireJS));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Asset.prototype._parseStyleSheet = function(filepath, file) {
      var c, dec, fullpath, rule, url, _i, _j, _len, _len1, _ref, _ref1;
      c = css.parse(file);
      _ref = c.stylesheet.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (rule.type === 'rule') {
          _ref1 = rule.declarations;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            dec = _ref1[_j];
            if (dec.type === 'declaration' && (dec.property === 'background-image' || dec.property === 'background')) {
              url = Asset.parseStyleSheetUrl(dec.value);
              if (url) {
                if (url.indexOf('/') === 0) {
                  fullpath = url;
                } else {
                  fullpath = join(path.dirname(filepath), url);
                }
                this._foundAssetReference(fullpath, dec);
              }
            }
          }
        }
      }
      return c;
    };

    Asset.prototype._toString = function() {
      var d, updated, _i, _len, _ref;
      if (this.minify) {
        return this._minify();
      }
      if (this.type === 'html') {
        if (typeof this.obj === 'string') {
          updated = this.obj;
        } else {
          updated = '';
          _ref = this.obj;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            d = _ref[_i];
            updated += htmlparser.DomUtils.getOuterHTML(d);
          }
        }
      } else if (this.type === 'javascript') {
        updated = this.obj.print_to_string({
          beautify: false
        });
      } else if (this.type === 'style') {
        updated = css.stringify(this.obj, {
          compress: false
        });
      } else if (this.type === 'image') {
        updated = this.obj;
      } else {
        updated = '';
      }
      return updated;
    };

    Asset.parseStyleSheetUrl = function(declaration) {
      var b, pos, pos2;
      b = declaration.match(/url\((.+?)\)/gi);
      if (b) {
        pos = declaration.indexOf('url(');
        if (pos >= 0) {
          pos2 = declaration.indexOf(')', pos + 4);
          return declaration.substring(pos + 4, pos2).trim();
        }
      }
      return '';
    };

    return Asset;

  })();

  AssetGraph = (function() {
    function AssetGraph(root) {
      this.root = root;
      this.nodes = {};
      this.indexNode = null;
    }

    AssetGraph.prototype.addCacheManifest = function() {};

    AssetGraph.prototype.loadAssets = function(filepath) {
      var absPath, f, files, _i, _len, _results;
      absPath = join(this.root, filepath);
      if (fs.statSync(absPath).isDirectory()) {
        files = fs.readdirSync(absPath);
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          f = files[_i];
          _results.push(this.loadAssets(join(filepath, f)));
        }
        return _results;
      } else {
        return this._load(filepath);
      }
    };

    AssetGraph.prototype.minifyAssets = function() {
      var a, p, _ref, _results;
      _ref = this.nodes;
      _results = [];
      for (p in _ref) {
        a = _ref[p];
        _results.push(a.minify = true);
      }
      return _results;
    };

    AssetGraph.prototype.moveAssets = function(destination) {
      var a, newpath, p, _ref, _results;
      _ref = this.nodes;
      _results = [];
      for (p in _ref) {
        a = _ref[p];
        if (p !== 'index.html') {
          newpath = join('/', destination, '/', path.basename(p));
          _results.push(a.move(newpath));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AssetGraph.prototype.setUrlPrefix = function(prefix) {
      var a, p, _ref, _results;
      _ref = this.nodes;
      _results = [];
      for (p in _ref) {
        a = _ref[p];
        if (p !== 'index.html') {
          _results.push(a.prefix = prefix);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AssetGraph.prototype.writeAssetsToDisc = function(destination, useHashName) {
      var a, p, _ref, _ref1, _results;
      if (useHashName == null) {
        useHashName = false;
      }
      _ref = this.nodes;
      for (p in _ref) {
        a = _ref[p];
        a.written = false;
      }
      _ref1 = this.nodes;
      _results = [];
      for (p in _ref1) {
        a = _ref1[p];
        _results.push(a.writeToDisc(destination, useHashName));
      }
      return _results;
    };

    AssetGraph.prototype._load = function(filepath) {
      var a, absPath;
      absPath = join(this.root, filepath);
      if (!fs.existsSync(absPath)) {
        console.log("file " + absPath + " not found");
        return;
      }
      a = new Asset(this.root, filepath, this);
      this.indexNode || (this.indexNode = a);
      this.addAsset(a);
      return a.resolveDependencies();
    };

    AssetGraph.prototype.addAsset = function(asset) {
      if (!this.nodes[asset.filepath] && (asset.type != null)) {
        this.nodes[asset.filepath] = asset;
        return true;
      }
      return false;
    };

    return AssetGraph;

  })();

  module.exports.AssetGraph = AssetGraph;

  module.exports.Asset = Asset;

}).call(this);
