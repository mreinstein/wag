// Generated by CoffeeScript 1.6.3
var Asset, AssetGraph, UglifyJS, crypto, css, fs, htmlparser, join, path, requireJS, _;

htmlparser = require('htmlparser2');

css = require('css');

UglifyJS = require('uglify-js');

path = require('path');

join = path.join;

fs = require('fs');

_ = require('underscore');

crypto = require('crypto');

/*
# parse html string as an underscore.js template, returning the list of 
# string locations for each dynamic section
parseHtmlUnderscoreTemplate = (html) ->
	idx = 0
	open = false
	dynamic = []
	while idx < html.length and idx >= 0
		if open
			q = '%>'
		else
			q = '<%'
		pos = html.indexOf q, idx
		if pos > -1
			if open
				dynamic.push { start: idx-2, end: pos+2 }
			open = !open
			idx = pos + 2
		else
			idx = pos
	# if any tags are left open, template has problemzz
	if open and dynamic.length > 0
		throw new Error('Invalid Template')
	dynamic

# given a DOM node, a set of changes, and a list of dynamic sections, product 
# an Html string that applies all changes and inserts the dynamic parts in
updateHtmlUnderscoreTemplate = (node, deltas, dynamic) ->
	# TODO
	# NOTE: templates/product.html is a great test example because it's large, 
	#		and has all 3 underscore tag types used:  <%   <%=   <%-
	''
*/


requireJS = null;

Asset = (function() {
  function Asset(root, filepath, ag) {
    var absPath;
    this.root = root;
    this.filepath = filepath;
    this.ag = ag != null ? ag : null;
    absPath = join(this.root, this.filepath);
    this.type = this._determineType(absPath);
    this.to = [];
    this.from = [];
    this.minified = null;
    this.hash = null;
    this.obj = this._buildObject(this.filepath, this.type);
  }

  Asset.prototype.hashValue = function() {
    var d, md5sum, newPath, node, _i, _j, _len, _len1, _ref, _ref1;
    if (this.hash) {
      return;
    }
    _ref = this.to;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node.asset.hash) {
        node.asset.hashValue();
      }
    }
    md5sum = crypto.createHash('md5');
    if (this.type === 'javascript') {
      md5sum.update(this.obj.print_to_string({
        beautify: false
      }));
      this.hash = md5sum.digest('hex');
    } else if (this.type === 'style') {
      if (this.minified) {
        md5sum.update(this.minified);
      } else {
        md5sum.update(css.stringify(this.obj));
      }
      this.hash = md5sum.digest('hex');
    } else if (this.type === 'html') {
      _ref1 = this.obj;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        d = _ref1[_j];
        md5sum.update(htmlparser.DomUtils.getOuterHTML(d));
      }
      this.hash = md5sum.digest('hex');
    } else if (this.type === 'image') {
      md5sum.update(this.obj);
      this.hash = md5sum.digest('hex');
    }
    newPath = path.dirname(this.filepath) + '/' + this.hash + path.extname(this.filepath);
    return this.move(newPath);
  };

  Asset.prototype.minify = function() {
    var compressor, d, node, _i, _j, _len, _len1, _ref, _ref1, _results;
    if (this.minified) {
      return;
    }
    _ref = this.to;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node.asset.minified) {
        node.asset.minify();
      }
    }
    console.log('minifying', this.filepath);
    if (this.type === 'javascript') {
      this.obj.figure_out_scope();
      compressor = UglifyJS.Compressor();
      this.obj.transform(compressor);
      return this.minified = this.obj.print_to_string({
        beautify: false
      });
    } else if (this.type === 'style') {
      return this.minified = css.stringify(this.obj, {
        compress: true
      });
    } else if (this.type === 'html') {
      if (typeof this.obj === 'string') {
        this.minified = this.obj;
        return;
      }
      this.minified = '';
      _ref1 = this.obj;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        d = _ref1[_j];
        _results.push(this.minified += htmlparser.DomUtils.getOuterHTML(d));
      }
      return _results;
    } else if (this.type === 'image') {
      return this.minfied = this.obj;
    }
  };

  Asset.prototype.move = function(destination) {
    var ext, f, oldpath, _i, _len, _ref;
    oldpath = JSON.parse(JSON.stringify(this.filepath));
    ext = path.extname(destination);
    _ref = this.from;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      if (f.asset.type === 'style') {
        f.node.value = "url(" + destination + ")";
      } else if (f.asset.type === 'javascript') {
        if (f.inRequireJS) {
          if (f.node.value.indexOf('text!') >= 0) {
            f.node.value = "text!" + destination;
          } else {
            f.node.value = join(path.dirname(destination), path.basename(destination, ext));
          }
        }
      } else if (f.asset.type === 'html') {
        f.node.value = 'text!' + destination;
      } else if (f.asset.type === 'image') {
        if (this.type === 'style') {
          f.node.value = "url(" + destination + ")";
        }
      } else {
        console.log('TODO: support type', f.asset.type, f.node, 'host type', this.type);
      }
    }
    this.filepath = destination;
    if (this.ag) {
      this.ag.addAsset(this);
      return delete this.ag.nodes[oldpath];
    }
  };

  Asset.prototype.writeToDisc = function(destination) {
    var d, out, _i, _len, _ref;
    if (this.minified) {
      return fs.writeFileSync(join(destination, this.filepath), this.minified);
    } else if (this.type === 'html') {
      if (typeof this.obj === 'string') {
        fs.writeFileSync(join(destination, this.filepath), this.obj);
        return;
      }
      out = '';
      _ref = this.obj;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        out += htmlparser.DomUtils.getOuterHTML(d);
      }
      return fs.writeFileSync(join(destination, this.filepath), out);
    } else if (this.type === 'javascript') {
      return fs.writeFileSync(join(destination, this.filepath), this.obj.print_to_string({
        beautify: true
      }));
    } else if (this.type === 'style') {
      return fs.writeFileSync(join(destination, this.filepath), css.stringify(this.obj, {
        compress: false
      }));
    } else {
      return fs.writeFileSync(join(destination, this.filepath), this.obj);
    }
  };

  Asset.prototype._buildObject = function(filepath, type) {
    var absPath, d, file, handler, parser,
      _this = this;
    absPath = join(this.root, filepath);
    if (!fs.existsSync(absPath)) {
      console.log("error:file " + absPath + " doesn't exist.");
      return null;
    }
    file = fs.readFileSync(absPath, 'utf8');
    if (type === 'html') {
      if (file.indexOf('<%') >= 0) {
        console.log('warnin: template directives found. Not parsing', filepath, file.length);
        return file;
      }
      d = null;
      handler = new htmlparser.DomHandler(function(er, dom) {
        var _i, _len;
        if (er) {
          throw new Error(er);
        } else {
          for (_i = 0, _len = dom.length; _i < _len; _i++) {
            d = dom[_i];
            _this._parseDOMNode(d);
          }
        }
        return d = dom;
      });
      parser = new htmlparser.Parser(handler);
      parser.parseComplete(file);
      return d;
    } else if (type === 'style') {
      return this._parseStyleSheet(filepath, file);
    } else if (type === 'javascript') {
      return this._parseJavascript(filepath, file);
    } else if (type === 'image') {
      return fs.readFileSync(absPath, 'utf8');
    }
    return null;
  };

  Asset.prototype._determineType = function(filepath) {
    var ext, type;
    ext = path.extname(filepath || '').split('.');
    ext = ext[ext.length - 1];
    if (ext === 'html' || ext === 'htm') {
      type = 'html';
    } else if (ext === 'js') {
      type = 'javascript';
    } else if (ext === 'css') {
      type = 'style';
    } else if (ext === 'png' || ext === 'gif' || ext === 'jpg' || ext === 'jpeg' || ext === 'ico' || ext === 'svg') {
      type = 'image';
    }
    return type;
  };

  Asset.prototype._foundAssetReference = function(filepath, node, inRequireJS) {
    var asset;
    if (inRequireJS == null) {
      inRequireJS = false;
    }
    if (!this.ag) {
      return;
    }
    if (!this.ag.nodes[filepath]) {
      console.log('loading ', filepath);
    }
    asset = this.ag.nodes[filepath] || new Asset(this.root, filepath, this.ag);
    if (asset.obj) {
      asset.from.push({
        asset: this,
        node: node,
        inRequireJS: inRequireJS
      });
      this.to.push({
        asset: asset,
        node: node,
        inRequireJS: inRequireJS
      });
      return this.ag.addAsset(asset);
    }
  };

  Asset.prototype._parseDOMNode = function(node) {
    var n, newAssetPath, _i, _len, _ref, _results;
    newAssetPath = null;
    if (node.type === 'tag' && (node.name === 'style' || node.name === 'link')) {
      newAssetPath = node.attribs.href;
    } else if (node.type === 'script' && node.name === 'script') {
      if (!node.attribs || !node.attribs.src) {

      } else {
        if (node.attribs['data-main']) {
          console.log('found requirejs entry point', node.attribs.src, 'main', node.attribs['data-main']);
          newAssetPath = "" + node.attribs['data-main'] + ".js";
        } else {
          console.log('external script found', node.attribs.src);
          newAssetPath = node.attribs.src;
        }
      }
    } else if (node.type === 'tag' && node.name === 'img' && node.attribs.src && node.attribs.src !== 'src') {
      console.log("found image reference '" + node.attribs.src + "'");
      newAssetPath = node.attribs.src;
    }
    if (newAssetPath) {
      this._foundAssetReference(newAssetPath, node);
    }
    if (node.children) {
      _ref = node.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(this._parseDOMNode(n));
      }
      return _results;
    }
  };

  Asset.prototype._parseJavascript = function(filepath, file) {
    var opts, toplevel, walker,
      _this = this;
    toplevel = null;
    opts = {};
    /*
    		opts =
    			filename : filepath
    			toplevel : toplevel
    */

    toplevel = UglifyJS.parse(file, opts);
    walker = new UglifyJS.TreeWalker(function(node) {
      if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'require') {
        if (node.expression.end.value === 'config') {
          requireJS = _this._parseRequireJSConfig(node);
        } else if (node.args.length === 2) {
          _this._parseRequireStatement(node);
        }
        return true;
      }
      if (node instanceof UglifyJS.AST_Call && node.start.type === 'name' && node.start.value === 'define') {
        _this._parseRequireStatement(node);
        return true;
      }
      return false;
    });
    toplevel.walk(walker);
    return toplevel;
  };

  Asset.prototype._parseRequireJSConfig = function(node) {
    var cfg, j, k, _i, _j, _len, _len1, _ref, _ref1;
    cfg = {};
    _ref = node.args[0].properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      if (k.key === 'baseUrl') {
        cfg.baseUrl = k.value.value;
      }
      if (k.key === 'paths') {
        cfg.paths = {};
        _ref1 = k.value.properties;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          j = _ref1[_j];
          cfg.paths[j.key] = j.value.value;
        }
      }
    }
    return cfg;
  };

  Asset.prototype._parseRequireStatement = function(node) {
    var alias, found, inRequireJS, newAssetPath, p, pa, scriptpath, _i, _len, _ref, _ref1, _results;
    if (!node.args[0].elements) {
      return;
    }
    p = requireJS ? requireJS.baseUrl : '';
    _ref = node.args[0].elements;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      scriptpath = _ref[_i];
      newAssetPath = null;
      if (scriptpath.value) {
        if (scriptpath.value.indexOf('text!') === 0) {
          newAssetPath = join(p, scriptpath.value.substring(5));
        } else if (fs.existsSync(join(this.root, p, "" + scriptpath.value + ".js"))) {
          newAssetPath = join(p, "" + scriptpath.value + ".js");
        } else if (scriptpath.value === 'exports' || (requireJS && scriptpath.value === 'require')) {

        } else if (requireJS) {
          found = false;
          _ref1 = requireJS.paths;
          for (alias in _ref1) {
            pa = _ref1[alias];
            if (alias === scriptpath.value) {
              found = true;
              newAssetPath = join(p, "" + pa + ".js");
            }
          }
          if (!found) {
            console.log("error 1: could not find asset " + scriptpath.value);
          }
        } else {
          console.log("error: could not find asset " + scriptpath.value);
        }
      }
      inRequireJS = true;
      if (newAssetPath) {
        _results.push(this._foundAssetReference(newAssetPath, scriptpath, inRequireJS));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Asset.prototype._parseStyleSheet = function(filepath, file) {
    var c, dec, fullpath, rule, url, _i, _j, _len, _len1, _ref, _ref1;
    c = css.parse(file);
    _ref = c.stylesheet.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      if (rule.type === 'rule') {
        _ref1 = rule.declarations;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          dec = _ref1[_j];
          if (dec.type === 'declaration' && (dec.property === 'background-image' || dec.property === 'background')) {
            url = Asset.parseStyleSheetUrl(dec.value);
            if (url) {
              if (url.indexOf('/') === 0) {
                fullpath = url;
              } else {
                fullpath = join(path.dirname(filepath), url);
              }
              this._foundAssetReference(fullpath, dec);
            }
          }
        }
      }
    }
    return c;
  };

  Asset.parseStyleSheetUrl = function(declaration) {
    var b, pos, pos2;
    b = declaration.match(/url\((.+?)\)/gi);
    if (b) {
      pos = declaration.indexOf('url(');
      if (pos >= 0) {
        pos2 = declaration.indexOf(')', pos + 4);
        return declaration.substring(pos + 4, pos2).trim();
      }
    }
    return '';
  };

  return Asset;

})();

AssetGraph = (function() {
  function AssetGraph(root) {
    this.root = root;
    this.nodes = {};
    this.indexNode = null;
  }

  AssetGraph.prototype.addCacheManifest = function() {};

  AssetGraph.prototype.loadAssets = function(filepath) {
    var absPath, f, files, _i, _len, _results;
    absPath = join(this.root, filepath);
    if (fs.statSync(absPath).isDirectory()) {
      files = fs.readdirSync(absPath);
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        f = files[_i];
        _results.push(this.loadAssets(join(filepath, f)));
      }
      return _results;
    } else {
      return this._load(filepath);
    }
  };

  AssetGraph.prototype.minifyAssets = function() {
    var a, p, _ref, _ref1, _results;
    _ref = this.nodes;
    for (p in _ref) {
      a = _ref[p];
      a.minified = false;
    }
    _ref1 = this.nodes;
    _results = [];
    for (p in _ref1) {
      a = _ref1[p];
      _results.push(a.minify());
    }
    return _results;
  };

  AssetGraph.prototype.moveAssets = function(destination) {
    var a, newpath, p, _ref, _results;
    _ref = this.nodes;
    _results = [];
    for (p in _ref) {
      a = _ref[p];
      if (p === 'index.html') {
        _results.push(newpath = p);
      } else {
        newpath = join('/', destination, '/', path.basename(p));
        _results.push(a.move(newpath));
      }
    }
    return _results;
  };

  AssetGraph.prototype.hashAssets = function() {
    var a, p, _ref, _ref1, _results;
    _ref = this.nodes;
    for (p in _ref) {
      a = _ref[p];
      a.hash = null;
    }
    _ref1 = this.nodes;
    _results = [];
    for (p in _ref1) {
      a = _ref1[p];
      if (p !== 'index.html') {
        _results.push(a.hashValue());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  AssetGraph.prototype.writeAssetsToDisc = function(destination) {
    var a, p, _ref, _results;
    _ref = this.nodes;
    _results = [];
    for (p in _ref) {
      a = _ref[p];
      _results.push(a.writeToDisc(destination));
    }
    return _results;
  };

  AssetGraph.prototype._load = function(filepath) {
    var a, absPath;
    absPath = join(this.root, filepath);
    if (!fs.existsSync(absPath)) {
      console.log("file " + absPath + " not found");
      return;
    }
    a = new Asset(this.root, filepath, this);
    this.indexNode || (this.indexNode = a);
    return this.addAsset(a);
  };

  AssetGraph.prototype.addAsset = function(asset) {
    if (!this.nodes[asset.filepath] && (asset.type != null)) {
      return this.nodes[asset.filepath] = asset;
    }
  };

  return AssetGraph;

})();

module.exports.AssetGraph = AssetGraph;

module.exports.Asset = Asset;
